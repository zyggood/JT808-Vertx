# JT808消息架构设计文档

## 概述

JT808消息架构是基于JT/T 808协议标准设计的消息处理框架，提供了完整的消息头和消息体的抽象定义。该架构采用面向对象的设计模式，支持消息的编码、解码、分包处理等核心功能。

## 消息结构

每条JT808消息由以下部分组成：

```
标识位 + 消息头 + 消息体 + 校验码 + 标识位
```

### 标识位

- **标识位**：采用 `0x7e` 表示消息的开始和结束
- **转义处理**：若校验码、消息头以及消息体中出现 `0x7e` 或 `0x7d`，需要进行转义处理

#### 转义规则

| 原始字节 | 转义后 |
|----------|--------|
| `0x7e` | `0x7d 0x02` |
| `0x7d` | `0x7d 0x01` |

#### 转义处理流程

**发送消息时**：消息封装 → 计算并填充校验码 → 转义处理

**接收消息时**：转义还原 → 验证校验码 → 解析消息

#### 转义示例

发送内容为 `0x30 0x7e 0x08 0x7d 0x55` 的数据包，经过封装后：
```
0x7e 0x30 0x7d 0x02 0x08 0x7d 0x01 0x55 0x7e
```

### 校验码

校验码计算方法：从消息头开始，与后续每个字节进行异或运算，直到校验码前一个字节，占用一个字节。

## 核心组件

### 1. JT808Message - 消息基类

`JT808Message` 是所有JT808协议消息的抽象基类，定义了消息的基本结构和行为。

#### 类结构

消息基类包含消息头、消息体和校验码三个核心字段。

#### 核心方法

| 方法名 | 返回类型 | 描述 |
|--------|----------|------|
| `getMessageId()` | `int` | 获取消息ID（抽象方法，子类必须实现） |
| `encodeBody()` | `Buffer` | 编码消息体（抽象方法，子类必须实现） |
| `decodeBody(Buffer body)` | `void` | 解码消息体（抽象方法，子类必须实现） |
| `getHeader()` | `JT808Header` | 获取消息头 |
| `setHeader(JT808Header header)` | `void` | 设置消息头 |
| `getBody()` | `Buffer` | 获取消息体 |
| `setBody(Buffer body)` | `void` | 设置消息体 |
| `getChecksum()` | `byte` | 获取校验码 |
| `setChecksum(byte checksum)` | `void` | 设置校验码 |

#### 设计特点

- **抽象设计**：采用抽象类设计，强制子类实现消息ID获取和编解码方法
- **Buffer支持**：使用Vert.x的Buffer类型处理二进制数据，提供高效的内存管理
- **校验机制**：内置校验码字段，确保数据传输的完整性

### 2. JT808Header - 消息头

`JT808Header` 类实现了JT808协议的消息头结构，包含消息的元数据信息。

#### 消息头结构

| 起始字节 | 字段 | 数据类型 | 描述及要求 |
|----------|------|----------|------------|
| 0 | 消息ID | WORD | 标识消息类型 |
| 2 | 消息体属性 | WORD | 消息体属性格式结构（见下文详细说明） |
| 4 | 终端手机号 | BCD[6] | 根据安装后终端自身的手机号转换。手机号不足12位，则在前补充数字，大陆手机号补充数字0，港澳台则根据其区号进行位数补充 |
| 10 | 消息流水号 | WORD | 按发送顺序从0开始循环累加 |
| 12 | 消息包封装项 | - | 如果消息体属性中相关标识位确定消息分包处理，则该项有内容，否则无该项 |

#### 字段说明

| 字段名 | 类型 | 描述 |
|--------|------|------|
| `messageId` | `int` | 消息ID，标识消息类型 |
| `messageProperty` | `int` | 消息体属性，包含长度、加密方式、分包标志等信息 |
| `protocolVersion` | `byte` | 协议版本号 |
| `phoneNumber` | `String` | 终端手机号（BCD[6]格式，不足12位前补0） |
| `serialNumber` | `int` | 消息流水号 |
| `packageInfo` | `PackageInfo` | 分包信息（可选） |

#### 消息体属性解析

消息体属性（messageProperty）是一个16位的字段，各位含义如下：

```
位15-14: 保留位
位13:    分包标志 (0:不分包, 1:分包)
位12-10: 数据加密方式 (000:不加密, 001:RSA加密)
位9-0:   消息体长度 (0-1023字节)
```

##### 数据加密方式说明

- **bit10~bit12**：数据加密标识位
- **当此三位都为0**：表示消息体不加密
- **当第10位为1**：表示消息体经过RSA算法加密
- **其他**：保留

##### 分包标志说明

- **当消息体属性中第13位为1时**：表示消息体为长消息，进行分包发送处理，具体分包信息由消息包封装项决定
- **若第13位为0**：则消息头中无消息包封装项字段

#### 核心方法

##### 核心操作方法

- **消息体长度操作**：提供获取和设置消息体长度的方法
- **加密方式操作**：支持获取和设置数据加密方式
- **分包标志操作**：提供分包标志的判断和设置功能
- **保留位操作**：支持保留位的获取和设置

### 3. PackageInfo - 分包信息

`PackageInfo` 是 `JT808Header` 的内部静态类，用于处理消息分包的相关信息。

#### 字段说明

| 字段名 | 类型 | 描述 |
|--------|------|------|
| `totalPackages` | `int` | 消息包总数 |
| `packageSequence` | `int` | 当前包序号（从1开始） |

#### 分包信息详细说明

当消息体属性中第13位为1时，表示消息体为长消息，需要进行分包发送处理：

| 起始字节 | 字段 | 数据类型 | 描述 |
|----------|------|----------|------|
| 0 | 消息总包数 | WORD | 该消息分包后的总包数 |
| 2 | 包序号 | WORD | 从1开始的包序号 |

#### 使用场景

当消息体长度超过单个数据包的最大承载能力时，需要进行分包处理。通过创建分包信息对象，设置总包数和当前包序号（从1开始），并在消息头中标记分包标志。

## 使用示例

### 1. 创建自定义消息类

继承JT808Message抽象基类，实现getMessageId()、encodeBody()和decodeBody()三个抽象方法。定义消息的具体内容字段和相应的getter/setter方法。

### 2. 构建完整消息

创建消息头对象，设置消息ID、终端手机号、流水号等基本信息。创建消息实例，设置消息头和消息内容。编码消息体并设置到消息对象中，同时更新消息头中的消息体长度。最后计算并设置校验码。

### 3. 处理分包消息

对于超过单包最大长度的消息，需要进行分包处理。计算总包数，为每个分包创建独立的消息对象，设置分包标志和分包信息，提取对应的消息内容片段。

## 设计优势

### 1. 模块化设计
- **职责分离**：消息头和消息体分离，便于维护和扩展
- **抽象封装**：通过抽象类定义统一接口，支持多种消息类型

### 2. 位操作优化
- **高效存储**：使用位操作处理消息属性，节省存储空间
- **快速解析**：通过位掩码快速提取各种标志位信息

### 3. 扩展性强
- **易于扩展**：新增消息类型只需继承基类并实现抽象方法
- **向后兼容**：支持协议版本管理，便于协议升级

### 4. 性能优化
- **Buffer支持**：使用Vert.x Buffer提供高效的内存管理
- **分包处理**：内置分包机制，支持大消息的可靠传输

## 最佳实践

### 1. 消息ID管理
建议使用常量类统一管理消息ID，将所有协议定义的消息ID集中定义，便于维护和查找。

### 2. 错误处理
在编解码过程中应当进行适当的错误处理，包括空值检查、数据格式验证等。对于解码失败的情况，应抛出明确的异常信息。

### 3. 日志记录
建议在关键操作点添加日志记录，重写toString()方法提供清晰的对象信息输出，便于调试和问题排查。

## 总结

JT808消息架构提供了一个完整、灵活、高效的消息处理框架。通过合理的抽象设计和位操作优化，既保证了协议的完整实现，又提供了良好的扩展性和性能表现。开发者可以基于这个架构快速实现各种JT808协议消息的处理逻辑。