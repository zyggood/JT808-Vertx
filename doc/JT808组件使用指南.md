# JT808组件使用指南

本文档介绍JT808-Vertx项目中新增的核心组件，包括消息工厂类、校验码工具类和转义工具类的使用方法。

## 组件概览

### 1. JT808MessageFactory - 消息工厂类
- **位置**: `com.jt808.protocol.factory.JT808MessageFactory`
- **功能**: 统一管理消息的创建、编码、解码和解析
- **特点**: 单例模式，支持自定义消息类型注册

### 2. ChecksumUtils - 校验码工具类
- **位置**: `com.jt808.protocol.util.ChecksumUtils`
- **功能**: 提供校验码计算和验证的专用方法
- **特点**: 支持多种数据格式，提供详细的验证结果

### 3. EscapeUtils - 转义工具类
- **位置**: `com.jt808.protocol.util.EscapeUtils`
- **功能**: 提供消息转义和反转义的专用方法
- **特点**: 完整的转义验证和错误检测

## 详细使用说明

### JT808MessageFactory 使用

#### 基本用法

```java
// 获取工厂实例
JT808MessageFactory factory = JT808MessageFactory.getInstance();

// 创建消息
JT808Message heartbeat = factory.createMessage(0x0002); // 终端心跳
JT808Message register = factory.createMessage(0x0100);  // 终端注册

// 编码消息
Buffer encoded = factory.encodeMessage(heartbeat);

// 解析消息
JT808Message parsed = factory.parseMessage(encoded);
```

#### 支持的消息类型

| 消息ID | 消息类型 | 说明 |
|--------|----------|------|
| 0x0001 | T0001TerminalCommonResponse | 终端通用应答 |
| 0x0002 | T0002TerminalHeartbeat | 终端心跳 |
| 0x0100 | T0100TerminalRegister | 终端注册 |
| 0x0102 | T0102TerminalAuth | 终端鉴权 |
| 0x0200 | T0200LocationReport | 位置信息汇报 |
| 0x8001 | T8001PlatformCommonResponse | 平台通用应答 |
| 0x8100 | T8100TerminalRegisterResponse | 终端注册应答 |

#### 注册自定义消息类型

```java
// 注册自定义消息
factory.registerMessage(0x9001, () -> new CustomMessage(0x9001));

// 检查是否支持
boolean supported = factory.isSupported(0x9001);

// 创建自定义消息
JT808Message customMessage = factory.createMessage(0x9001);
```

### ChecksumUtils 使用

#### 基本校验码计算

```java
// 计算字节数组的校验码
byte[] data = {0x01, 0x02, 0x03, 0x04};
byte checksum = ChecksumUtils.calculateChecksum(data);

// 计算Buffer的校验码
Buffer buffer = Buffer.buffer(data);
byte bufferChecksum = ChecksumUtils.calculateChecksum(buffer);

// 计算部分数据的校验码
byte partialChecksum = ChecksumUtils.calculateChecksum(data, 1, 2);
```

#### 校验码验证

```java
// 验证校验码
boolean isValid = ChecksumUtils.verifyChecksum(data, expectedChecksum);

// 验证完整JT808消息的校验码
ChecksumUtils.ChecksumResult result = ChecksumUtils.verifyCompleteMessage(completeMessage);
if (result.isValid()) {
    System.out.println("校验码验证成功");
} else {
    System.out.println("校验码验证失败: " + result.getMessage());
}
```

#### ChecksumResult 结果对象

```java
ChecksumResult result = ChecksumUtils.verifyCompleteMessage(message);

// 获取验证结果
boolean valid = result.isValid();

// 获取实际计算的校验码
byte actual = result.getActualChecksum();

// 获取期望的校验码
byte expected = result.getExpectedChecksum();

// 获取验证消息
String message = result.getMessage();
```

### EscapeUtils 使用

#### 基本转义操作

```java
// 转义处理
Buffer originalData = Buffer.buffer(new byte[]{0x01, 0x7E, 0x02, 0x7D, 0x03});
Buffer escapedData = EscapeUtils.escape(originalData);

// 反转义处理
Buffer unescapedData = EscapeUtils.unescape(escapedData);

// 字节数组转义
byte[] array = {0x7E, 0x7D};
Buffer escapedArray = EscapeUtils.escape(array);
```

#### 转义检查和统计

```java
// 检查是否需要转义
boolean needsEscape = EscapeUtils.needsEscape(data);

// 统计需要转义的字节数
int escapeCount = EscapeUtils.countEscapeBytes(data);

// 计算转义后的长度
int escapedLength = EscapeUtils.calculateEscapedLength(originalLength, escapeCount);
```

#### 转义数据验证

```java
// 验证转义数据的完整性
EscapeUtils.EscapeValidationResult validation = EscapeUtils.validateEscapedData(escapedData);

if (validation.isValid()) {
    System.out.println("转义数据有效");
} else {
    System.out.println("转义数据无效: " + validation.getMessage());
}
```

## 转义规则说明

JT808协议的转义规则：

| 原始字节 | 转义后 | 说明 |
|----------|--------|------|
| 0x7E | 0x7D 0x02 | 标识位转义 |
| 0x7D | 0x7D 0x01 | 转义标识符转义 |

## 校验码计算说明

JT808协议使用异或校验：
- 校验码 = 消息头 ⊕ 消息体的所有字节
- 校验范围：从消息ID开始到消息体结束
- 不包括：起始标识位(0x7E)、校验码本身、结束标识位(0x7E)

## 完整使用示例

```java
public class JT808Example {
    public void processMessage() throws ProtocolException {
        // 1. 获取工厂实例
        JT808MessageFactory factory = JT808MessageFactory.getInstance();
        
        // 2. 创建消息
        JT808Message heartbeat = factory.createMessage(0x0002);
        JT808Header header = new JT808Header(0x0002, "13800138000", 1);
        heartbeat.setHeader(header);
        
        // 3. 编码消息
        Buffer encoded = factory.encodeMessage(heartbeat);
        
        // 4. 验证校验码
        ChecksumUtils.ChecksumResult checksumResult = 
            ChecksumUtils.verifyCompleteMessage(encoded);
        
        if (checksumResult.isValid()) {
            System.out.println("消息校验码正确");
        }
        
        // 5. 检查是否需要转义
        if (EscapeUtils.needsEscape(encoded)) {
            System.out.println("消息包含需要转义的字符");
        }
        
        // 6. 解析消息
        JT808Message parsed = factory.parseMessage(encoded);
        System.out.println("解析成功: " + parsed.getClass().getSimpleName());
    }
}
```

## 错误处理

### 常见错误类型

1. **校验码错误**
   ```java
   ChecksumResult result = ChecksumUtils.verifyCompleteMessage(message);
   if (!result.isValid()) {
       // 处理校验码错误
       logger.error("校验码验证失败: {}", result.getMessage());
   }
   ```

2. **转义数据无效**
   ```java
   EscapeValidationResult validation = EscapeUtils.validateEscapedData(data);
   if (!validation.isValid()) {
       // 处理转义错误
       logger.error("转义数据无效: {}", validation.getMessage());
   }
   ```

3. **消息解析异常**
   ```java
   try {
       JT808Message message = factory.parseMessage(buffer);
   } catch (ProtocolException e) {
       // 处理协议异常
       logger.error("消息解析失败: {}", e.getMessage());
   }
   ```

## 性能考虑

1. **消息工厂**: 使用单例模式，避免重复创建实例
2. **校验码计算**: 对于大量数据，考虑使用部分校验
3. **转义处理**: 先检查是否需要转义，避免不必要的处理
4. **内存管理**: 及时释放不再使用的Buffer对象

## 最佳实践

1. **统一使用工厂类**：所有消息创建和解析都通过MessageFactory进行
2. **验证数据完整性**：在处理消息前先验证校验码和转义数据
3. **错误处理**：妥善处理各种异常情况，提供详细的错误信息
4. **日志记录**：记录关键操作和错误信息，便于调试和监控
5. **单元测试**：为自定义消息类型编写完整的单元测试

## 扩展开发

### 添加新的消息类型

1. 创建消息类继承`JT808Message`
2. 实现`getMessageId()`、`encodeBody()`、`decodeBody()`方法
3. 通过工厂类注册新消息类型
4. 编写对应的单元测试

### 自定义校验算法

如需使用其他校验算法，可以扩展`ChecksumUtils`类或创建新的校验工具类。

### 自定义转义规则

如需支持其他转义规则，可以扩展`EscapeUtils`类或创建新的转义工具类。